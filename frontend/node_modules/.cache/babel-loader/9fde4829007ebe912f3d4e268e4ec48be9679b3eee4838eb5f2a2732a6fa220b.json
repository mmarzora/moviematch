{"ast":null,"code":"import { db } from '../firebase';\nimport { doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp, arrayUnion, writeBatch, runTransaction } from 'firebase/firestore';\nimport { generateSessionCode } from '../utils/sessionUtils';\nexport const sessionService = {\n  // Create a new session\n  createSession: async creatorId => {\n    try {\n      const code = generateSessionCode();\n      const sessionRef = doc(db, 'sessions', code);\n      const sessionData = {\n        id: code,\n        code,\n        created: serverTimestamp(),\n        active: true,\n        members: [creatorId],\n        currentMovieId: null,\n        viewedMovies: [],\n        swipes: {},\n        matches: [],\n        userHistory: {\n          [creatorId]: []\n        },\n        useSmartMatching: true // Default to true for new sessions\n      };\n      await setDoc(sessionRef, sessionData);\n      return sessionData;\n    } catch (error) {\n      throw new Error(`Failed to create session: ${error.message}`);\n    }\n  },\n  // Join an existing session\n  joinSession: async (code, memberId) => {\n    const sessionRef = doc(db, 'sessions', code);\n    const snapshot = await getDoc(sessionRef);\n    if (!snapshot.exists()) {\n      throw new Error('Session not found');\n    }\n    const sessionData = snapshot.data();\n    if (!sessionData.active) {\n      throw new Error('Session is no longer active');\n    }\n    if (sessionData.members.length >= 2) {\n      throw new Error('Session is full');\n    }\n    if (sessionData.members.includes(memberId)) {\n      return sessionData;\n    }\n\n    // Initialize user history for new member\n    const userHistory = {\n      ...sessionData.userHistory,\n      [memberId]: []\n    };\n    await updateDoc(sessionRef, {\n      members: arrayUnion(memberId),\n      userHistory\n    });\n    const updatedSnapshot = await getDoc(sessionRef);\n    return updatedSnapshot.data();\n  },\n  // Listen to session changes\n  subscribeToSession: (sessionId, callback) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    return onSnapshot(sessionRef, {\n      includeMetadataChanges: true\n    }, snapshot => {\n      if (!snapshot.exists()) {\n        callback(null);\n        return;\n      }\n      const data = snapshot.data();\n      callback(data);\n    }, () => callback(null));\n  },\n  // Update movie swipe with independent progression\n  updateMovieSwipe: async (sessionId, memberId, movieId, liked) => {\n    try {\n      console.log('Starting updateMovieSwipe:', {\n        sessionId,\n        memberId,\n        movieId,\n        liked\n      });\n      const sessionRef = doc(db, 'sessions', sessionId);\n      const snapshot = await getDoc(sessionRef);\n      if (!snapshot.exists()) {\n        throw new Error(`Session not found: ${sessionId}`);\n      }\n      const sessionData = snapshot.data();\n\n      // Validate member belongs to session\n      if (!sessionData.members.includes(memberId)) {\n        throw new Error(`Member ${memberId} not found in session ${sessionId}`);\n      }\n\n      // Initialize swipes if needed\n      const swipes = sessionData.swipes || {};\n      if (!swipes[movieId]) {\n        swipes[movieId] = {};\n      }\n      swipes[movieId][memberId] = liked;\n\n      // Create history entry with current timestamp\n      const historyEntry = {\n        movieId,\n        decision: liked,\n        timestamp: Date.now()\n      };\n\n      // Initialize user history if needed\n      if (!sessionData.userHistory) {\n        sessionData.userHistory = {};\n      }\n      if (!sessionData.userHistory[memberId]) {\n        sessionData.userHistory[memberId] = [];\n      }\n      const userHistory = {\n        ...sessionData.userHistory,\n        [memberId]: [...(sessionData.userHistory[memberId] || []), historyEntry]\n      };\n\n      // Check for match with other user's previous swipes\n      const otherMember = sessionData.members.find(id => id !== memberId);\n      const isMatch = otherMember && swipes[movieId][otherMember] === true && liked;\n      console.log('Preparing batch update:', {\n        swipes: Object.keys(swipes).length,\n        userHistoryLength: userHistory[memberId].length,\n        isMatch\n      });\n      const batch = writeBatch(db);\n      batch.update(sessionRef, {\n        swipes,\n        viewedMovies: arrayUnion(movieId),\n        userHistory,\n        ...(isMatch && {\n          matches: arrayUnion(movieId)\n        })\n      });\n      await batch.commit();\n      console.log('Successfully updated session with swipe');\n    } catch (error) {\n      console.error('Error in updateMovieSwipe:', {\n        error: error.message,\n        stack: error.stack,\n        sessionId,\n        memberId,\n        movieId\n      });\n      throw new Error(`Failed to update movie swipe: ${error.message}`);\n    }\n  },\n  // Update current movie for a specific user\n  updateCurrentMovie: async (sessionId, movieId) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const batch = writeBatch(db);\n    batch.update(sessionRef, {\n      currentMovieId: movieId\n    });\n    await batch.commit();\n  },\n  // Leave session\n  leaveSession: async (sessionId, memberId) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const snapshot = await getDoc(sessionRef);\n    if (!snapshot.exists()) return;\n    const sessionData = snapshot.data();\n    const updatedMembers = sessionData.members.filter(id => id !== memberId);\n    const batch = writeBatch(db);\n    batch.update(sessionRef, {\n      members: updatedMembers,\n      active: updatedMembers.length > 0\n    });\n    await batch.commit();\n  },\n  // Get user's swipe history\n  getUserHistory: async (sessionId, memberId) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const snapshot = await getDoc(sessionRef);\n    if (!snapshot.exists()) {\n      throw new Error('Session not found');\n    }\n    const sessionData = snapshot.data();\n    return sessionData.userHistory[memberId] || [];\n  },\n  // Set matching session ID atomically if absent\n  setMatchingSessionIdIfAbsent: async (sessionId, matchingSessionId) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    await runTransaction(db, async transaction => {\n      const sessionDoc = await transaction.get(sessionRef);\n      if (!sessionDoc.exists()) {\n        throw new Error('Session not found');\n      }\n      const sessionData = sessionDoc.data();\n\n      // Only set if not already present (atomic check-and-set)\n      if (!sessionData.matchingSessionId) {\n        transaction.update(sessionRef, {\n          matchingSessionId\n        });\n        console.log('[SessionService] Set matching session ID:', matchingSessionId);\n      } else {\n        console.log('[SessionService] Matching session ID already exists:', sessionData.matchingSessionId);\n      }\n    });\n  }\n};","map":{"version":3,"names":["db","doc","setDoc","getDoc","updateDoc","onSnapshot","serverTimestamp","arrayUnion","writeBatch","runTransaction","generateSessionCode","sessionService","createSession","creatorId","code","sessionRef","sessionData","id","created","active","members","currentMovieId","viewedMovies","swipes","matches","userHistory","useSmartMatching","error","Error","message","joinSession","memberId","snapshot","exists","data","length","includes","updatedSnapshot","subscribeToSession","sessionId","callback","includeMetadataChanges","updateMovieSwipe","movieId","liked","console","log","historyEntry","decision","timestamp","Date","now","otherMember","find","isMatch","Object","keys","userHistoryLength","batch","update","commit","stack","updateCurrentMovie","leaveSession","updatedMembers","filter","getUserHistory","setMatchingSessionIdIfAbsent","matchingSessionId","transaction","sessionDoc","get"],"sources":["/Users/maitemarzoratti/Documents/data-science/MovieMatch/moviematch/frontend/src/services/sessionService.ts"],"sourcesContent":["import { db } from '../firebase';\nimport { \n  doc, \n  setDoc, \n  getDoc, \n  updateDoc, \n  onSnapshot,\n  serverTimestamp,\n  arrayUnion,\n  writeBatch,\n  Timestamp,\n  runTransaction\n} from 'firebase/firestore';\nimport { generateSessionCode } from '../utils/sessionUtils';\n\nexport interface UserSwipeHistory {\n  movieId: number;\n  decision: boolean;\n  timestamp: number;\n}\n\nexport interface Session {\n  id: string;\n  code: string;\n  created: Timestamp;\n  active: boolean;\n  members: string[];\n  currentMovieId: number | null;\n  viewedMovies: number[];\n  swipes: {\n    [movieId: string]: {\n      [memberId: string]: boolean;\n    };\n  };\n  matches: number[];\n  userHistory: {\n    [memberId: string]: UserSwipeHistory[];\n  };\n  matchingSessionId?: string; // For shared algorithm session across browsers\n  useSmartMatching: boolean; // Flag to indicate if smart matching is enabled\n}\n\nexport const sessionService = {\n  // Create a new session\n  createSession: async (creatorId: string): Promise<Session> => {\n    try {\n      const code = generateSessionCode();\n      const sessionRef = doc(db, 'sessions', code);\n      const sessionData: Session = {\n        id: code,\n        code,\n        created: serverTimestamp() as Timestamp,\n        active: true,\n        members: [creatorId],\n        currentMovieId: null,\n        viewedMovies: [],\n        swipes: {},\n        matches: [],\n        userHistory: {\n          [creatorId]: []\n        },\n        useSmartMatching: true // Default to true for new sessions\n      };\n\n      await setDoc(sessionRef, sessionData);\n      return sessionData;\n    } catch (error: any) {\n      throw new Error(`Failed to create session: ${error.message}`);\n    }\n  },\n\n  // Join an existing session\n  joinSession: async (code: string, memberId: string): Promise<Session> => {\n    const sessionRef = doc(db, 'sessions', code);\n    const snapshot = await getDoc(sessionRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Session not found');\n    }\n\n    const sessionData = snapshot.data() as Session;\n    \n    if (!sessionData.active) {\n      throw new Error('Session is no longer active');\n    }\n\n    if (sessionData.members.length >= 2) {\n      throw new Error('Session is full');\n    }\n\n    if (sessionData.members.includes(memberId)) {\n      return sessionData;\n    }\n\n    // Initialize user history for new member\n    const userHistory = {\n      ...sessionData.userHistory,\n      [memberId]: []\n    };\n\n    await updateDoc(sessionRef, {\n      members: arrayUnion(memberId),\n      userHistory\n    });\n\n    const updatedSnapshot = await getDoc(sessionRef);\n    return updatedSnapshot.data() as Session;\n  },\n\n  // Listen to session changes\n  subscribeToSession: (sessionId: string, callback: (session: Session | null) => void) => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    \n    return onSnapshot(\n      sessionRef,\n      { includeMetadataChanges: true },\n      (snapshot) => {\n        if (!snapshot.exists()) {\n          callback(null);\n          return;\n        }\n        const data = snapshot.data() as Session;\n        callback(data);\n      },\n      () => callback(null)\n    );\n  },\n\n  // Update movie swipe with independent progression\n  updateMovieSwipe: async (sessionId: string, memberId: string, movieId: number, liked: boolean): Promise<void> => {\n    try {\n      console.log('Starting updateMovieSwipe:', {\n        sessionId,\n        memberId,\n        movieId,\n        liked\n      });\n\n      const sessionRef = doc(db, 'sessions', sessionId);\n      const snapshot = await getDoc(sessionRef);\n      \n      if (!snapshot.exists()) {\n        throw new Error(`Session not found: ${sessionId}`);\n      }\n\n      const sessionData = snapshot.data() as Session;\n\n      // Validate member belongs to session\n      if (!sessionData.members.includes(memberId)) {\n        throw new Error(`Member ${memberId} not found in session ${sessionId}`);\n      }\n\n      // Initialize swipes if needed\n      const swipes = sessionData.swipes || {};\n      if (!swipes[movieId]) {\n        swipes[movieId] = {};\n      }\n      swipes[movieId][memberId] = liked;\n\n      // Create history entry with current timestamp\n      const historyEntry: UserSwipeHistory = {\n        movieId,\n        decision: liked,\n        timestamp: Date.now()\n      };\n\n      // Initialize user history if needed\n      if (!sessionData.userHistory) {\n        sessionData.userHistory = {};\n      }\n      if (!sessionData.userHistory[memberId]) {\n        sessionData.userHistory[memberId] = [];\n      }\n\n      const userHistory = {\n        ...sessionData.userHistory,\n        [memberId]: [...(sessionData.userHistory[memberId] || []), historyEntry]\n      };\n\n      // Check for match with other user's previous swipes\n      const otherMember = sessionData.members.find(id => id !== memberId);\n      const isMatch = otherMember && swipes[movieId][otherMember] === true && liked;\n\n      console.log('Preparing batch update:', {\n        swipes: Object.keys(swipes).length,\n        userHistoryLength: userHistory[memberId].length,\n        isMatch\n      });\n\n      const batch = writeBatch(db);\n      batch.update(sessionRef, {\n        swipes,\n        viewedMovies: arrayUnion(movieId),\n        userHistory,\n        ...(isMatch && { matches: arrayUnion(movieId) })\n      });\n\n      await batch.commit();\n      console.log('Successfully updated session with swipe');\n    } catch (error: any) {\n      console.error('Error in updateMovieSwipe:', {\n        error: error.message,\n        stack: error.stack,\n        sessionId,\n        memberId,\n        movieId\n      });\n      throw new Error(`Failed to update movie swipe: ${error.message}`);\n    }\n  },\n\n  // Update current movie for a specific user\n  updateCurrentMovie: async (sessionId: string, movieId: number): Promise<void> => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const batch = writeBatch(db);\n    \n    batch.update(sessionRef, {\n      currentMovieId: movieId\n    });\n\n    await batch.commit();\n  },\n\n  // Leave session\n  leaveSession: async (sessionId: string, memberId: string): Promise<void> => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const snapshot = await getDoc(sessionRef);\n    \n    if (!snapshot.exists()) return;\n\n    const sessionData = snapshot.data() as Session;\n    const updatedMembers = sessionData.members.filter(id => id !== memberId);\n\n    const batch = writeBatch(db);\n    batch.update(sessionRef, {\n      members: updatedMembers,\n      active: updatedMembers.length > 0\n    });\n\n    await batch.commit();\n  },\n\n  // Get user's swipe history\n  getUserHistory: async (sessionId: string, memberId: string): Promise<UserSwipeHistory[]> => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    const snapshot = await getDoc(sessionRef);\n    \n    if (!snapshot.exists()) {\n      throw new Error('Session not found');\n    }\n\n    const sessionData = snapshot.data() as Session;\n    return sessionData.userHistory[memberId] || [];\n  },\n\n  // Set matching session ID atomically if absent\n  setMatchingSessionIdIfAbsent: async (sessionId: string, matchingSessionId: string): Promise<void> => {\n    const sessionRef = doc(db, 'sessions', sessionId);\n    \n    await runTransaction(db, async (transaction) => {\n      const sessionDoc = await transaction.get(sessionRef);\n      \n      if (!sessionDoc.exists()) {\n        throw new Error('Session not found');\n      }\n      \n      const sessionData = sessionDoc.data() as Session;\n      \n      // Only set if not already present (atomic check-and-set)\n      if (!sessionData.matchingSessionId) {\n        transaction.update(sessionRef, { matchingSessionId });\n        console.log('[SessionService] Set matching session ID:', matchingSessionId);\n      } else {\n        console.log('[SessionService] Matching session ID already exists:', sessionData.matchingSessionId);\n      }\n    });\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}